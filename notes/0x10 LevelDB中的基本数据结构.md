# LevelDB中的基本数据结构

## 0x11 Slice

`Slice`是一个简单的Structure，包含一个长度（length）和一个**指向外部字节数组的指针**。LevelDB方法中返回的key和value都是`Slice`类型的，而不是`std::string`或C风格的字符串，这是因为：

- 不使用`std::string`是因为：LevelDB不需要复制潜在的较大的key和value，使用`Slice`开销更小；
- 不使用C风格的字符串是因为：LevelDB的key和value中允许包含`\0`;

##  0x12 Varint

#### 作用

- `Varint`是一种比较特殊的整数类型，它包含有`Varint32`和`Varint64`两种，它相比于`int32`和`int64`最大的特点是长度可变。

### 机制

- `Varint`是一种紧凑的表示数字的方法，它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。采用`Varint`，对于很小的`int32`类型的数字，则可以用1个字节来表示。大的数字则可能需要5个字节来表示。
- `Varint`中的每个字节的最高位（bit）有特殊含义，如果该位为1，表示后续的字节也是这个数字的一部分，如果该位为0，则结束。其他的7位（bit）都表示数字。

实例：

```
因为每个字节的最高位用作了标识位，所以每个字节中只有7位能用来存储数字，而7位能表示的最大数是127，因此小于128的数字都可以用一个字节表示；
大于等于128的数字，比如说300，会用两个字节在内存中表示为：
原始二进制：    100101100
编码后二进制： 00000010 10101100
对于上面编码后的二进制，第二个字节中的高位是标识位，用于标识后续的字节也是这个数字的一部分，
所以00000010 10101100可以实际看作00000010 (1)0101100，也就是把第二个字节的高位要去掉来连接，也就是00000010  0101100，
这就是我们编码前的原始二进制位了。
实际应用中，高位字节是放在后续字节中的，所以实际格式如下；
低              高
10101100 00000010
```



